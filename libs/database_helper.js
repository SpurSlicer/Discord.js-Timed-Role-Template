// -----------------------IMPORTS-----------------------
const { Sequelize, DataTypes } = require('sequelize');
const { guildId } = require('../jsons/config.json');
const { roles } = require('../jsons/role_info.json');
const { minitify } = require('../libs/command_gen_helper');

// ------------------------------------------------------
// @description [see below]
// 1. Create the database if it doesn't exist or retrieve it from ../database/database.sqlite
// 2. Establish/remember the Instance table format
//   Columns:
//      - user_id
//      - role_id
//      - end_time (seconds starting from 1970)
// 3. Then attempt to sync the database
// @return the database reference and [UNUSED]-> table structure
// ------------------------------------------------------
async function getDatabase() {
    const database = new Sequelize({
        host: 'localhost',
        dialect: 'sqlite',
        logging: false,
        storage: './database/database.sqlite',
    });    
    const table = database.define('Instance', {    
        user_id: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        role_id: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        end_time: {
            type: DataTypes.INTEGER,
            allowNull: false,
        }
    });
    try {
        await database.sync();
        console.log(`[LOG] [DATABASE] creation successful!`);
    } catch (e) {
        console.log(`[ERROR] [DATABASE] creation unsuccessful: ${e}`);
    }
    return {
        "database": database,
        "table": table
    };
}

// ------------------------------------------------------
// @description Check whether a specified user with a specified role is in the database
// @params database_info: a reference to the database
// @params info: an object with {user_id:..., role_id...}
// @return whether the given user info.user_id with role info.role_id is in the database or not
// ------------------------------------------------------
async function isInDatabase(database_info, info) {
    const instances = await database_info.table.findAll({
        where: {
            user_id: info.user_id,
            role_id: info.role_id
        },
    });
    return (instances.length != 0);
}

// ------------------------------------------------------
// @description remove a role from a user
// @params role: the role object (only needs role.role_id) to be removed
// @params interaction: the discord interaction object generated by the user interaction.member (the one who executed the command)
// ------------------------------------------------------
async function removeRoleFromUser(role, interaction) {
    if (interaction == null) return;
    await interaction.member.roles.remove(role.role_id);
}

// ------------------------------------------------------
// @description remove a role from a user via the client instead of interaction
// @params info: an object with {user_id:..., role_id:...}
// @params client: the discord client object
// ------------------------------------------------------
async function removeRoleFromUserByClient(info, client) {
    if (client == null) return;
    const guild = client.guilds.cache.get(guildId);
    const user = await guild.members.fetch(info.user_id);
    await user.roles.remove(info.role_id);
}

// ------------------------------------------------------
// @description gives a specified role to a user
// @params role: the role object (only needs role.role_id) to be added
// @params interaction: the discord interaction object generated by the user interaction.member (the one who executed the command)
// ------------------------------------------------------
async function addRoleToUser(role, interaction) {
    if (interaction == null) return;
    await interaction.member.roles.add(role.role_id);
}

// ------------------------------------------------------
// @description empties the entire instance table and removes all tracked roles from all users (clean wipe both in the database and server)
//   - NOTE: this is a DANGEROUS function and should only be used as a failsafe
// @params database_info: a reference to the database
// @params client: the discord client object
// ------------------------------------------------------
async function clearDatabase(database_info, client) {
    const instances = await database_info.table.findAll();
    for (const instance of instances) {
        await removeRoleFromUserByClient(instance, client);
    }
    await database_info.table.destroy({
        where: {},
        truncate: true
    });
}

// ------------------------------------------------------
// @description Checks every user in the database to see if their roles have expired and removes them from the user
// Naturally, it removes the user's entry in the database as well to keep it clean
//   - NOTE: this function should only be used in an interval or infinite loop; it's how the bot actually removes roles (see index.js)
// @params database_info: a reference to the database
// @params client: the discord client object
// ------------------------------------------------------
async function checkDatabase(database_info, client) {
    const instances = await database_info.table.findAll();
    for (const instance of instances) {
        if (instance.end_time < new Date().getTime()) {
            await removeRoleFromUserByClient(instance, client);
            console.log(`  [LOG] [Database] deleting row for user ${instance.user_id} of role ${instance.role_id}`);
            await database_info.table.destroy({
                where: {
                    user_id: instance.user_id,
                    role_id: instance.role_id,
                    end_time: instance.end_time
                },
            });
        }
    }
}

// ------------------------------------------------------
// @description removes an entry from the database based on the info.user_id and role_id passed
// @params database_info: a reference to the database
// @params info: an object with {user_id:..., role_id:...}
// ------------------------------------------------------
async function deleteFromDatabase(database_info, info) {
    await database_info.table.destroy({
        where: {
            user_id: info.user_id,
            role_id: info.role_id
        },
    });
}

// ------------------------------------------------------
// @description Either adds a user to the database upon giving them the requested role for their requested time or updates their role time.
// This function is primarily triggered by the execution of any timed_role command from ../commands/timed_role_template.js with a few unnotable exceptions
// 1. it starts by seeing if a separate user_id was entered that isn't that of the interaction. It then uses whichever user_id is actually usable
// 2. Then it queries the database for all entries that the given user has for the provided role object (uses role.role_id)
//   Conditional Description:
//      a. if (instances.length > 1) -> Perform an fringe case check to make sure the user doesn't have multiple entries in the database for the same role 
//         (such an occurance shouldn't happen but this handles it just in case) 
//      b. else if (instances.length == 0) -> So the requested role isn't in the database. 
//         First check if the user doesn't want the role removed (removing the role should do nothing). 
//         If not, add the role and move onto the switch case as every case would end up adding the role at some point:
//            NOTE: the nullish operator (?.) is used because option has the chance of being null.
//              i. case: undefined or case: null -> no option was selected, so do one of the following:
//                  1. Should there not be any qualifiers or if the user didn't select one, give the user the default role duration found in ../jsons/role_info.json
//                  2. A qualifier was selected, so use that time instead of the role's default time (use option.qualifier.value instead of role.role_duration)
//              ii. case: perma -> give the user the role for infinity time so it is never removed
//              ii. case: remove -> do nothing as the user never had the role in the first place
//      c. else -> The user had one entry, so update that entry instead of adding a new one. Here's the switch case breakdown:
//              i. case: undefined or case: null -> no option was selected, so do one of the following:
//                  1. Should there not be any qualifiers or if the user didn't select one, update the user's role with the default role duration found in ../jsons/role_info.json
//                  2. A qualifier was selected, so use that time instead of the role's default time in the update (use option.qualifier.value instead of role.role_duration)
//              ii. case: perma -> update the user's the role duration to infinity time so it is never removed
//              ii. case: remove -> remove the role from the user and the database
// @params database_info: a reference to the database
// @params role: the standard role object with {role_id:..., role_duration:...} used
// @params interaction: the discord interaction object generated by the user interaction.member (the one who executed the command)
// @params option: the option object consisting of {duration:..., qualifier:...}, both of which are entered as command parameters
// @params separate_user_id -> an alternate id used instead of the interaction.member id if it's entered
// ------------------------------------------------------
async function createOrUpdateDatabase(database_info, role, interaction, option, separate_user_id=null) {
    const user_id = (separate_user_id == null) ? interaction.member.id : separate_user_id;
    const instances = await database_info.table.findAll({
        where: {
            user_id: user_id,
            role_id: role.role_id
        },
    });
    if (instances.length > 1) { // if multiple entries, clean up and simulate an update
        console.log(`[ERROR] user ${user_id} of role ${role.role_name} (${role.role_id}) has ${instances.length} instances of having the same role!!!\n\tDeleting all and startin fresh...`);
        await deleteFromDatabase(database_info, { user_id: user_id, role_id: role.role_id });
        await database_info.table.create({ "user_id": user_id, "role_id": role.role_id, "end_time": Number.POSITIVE_INFINITY }); /* +inf just so it doesn't remove the role by accident during checks */
        await createOrUpdateDatabase(database_info, role, interaction, option); // [RECURSIVE CALL]
        return;
    } else if (instances.length == 0) { // if no entry, make new
        if (option?.duration?.value != 'remove') addRoleToUser({user_id: user_id, role_id: role.role_id}, interaction);
        switch (option?.duration?.value) {
            case undefined:
            case null:
                if ((option?.qualifier == null) || (option?.qualifier == undefined)) {
                    await database_info.table.create({ "user_id": user_id, "role_id": role.role_id, "end_time": new Date().getTime() + role.role_duration });
                    await interaction?.reply({ content: `Role <@&${role.role_id}> added for ${minitify(role.role_duration)} ${(minitify(role.role_duration) == 1) ? ('minute') : ('minutes')}`, ephemeral: true });
                } else {
                    await database_info.table.create({ "user_id": user_id, "role_id": role.role_id, "end_time": new Date().getTime() + option.qualifier.value });
                    const qualifier_duration = (option.qualifier.value == null) ? (minitify(role.role_duration)) : (minitify(option.qualifier.value));
                    await interaction?.reply({ content: `Role <@&${role.role_id}> added for ${qualifier_duration} ${(qualifier_duration == 1) ? ('minute') : ('minutes')}`, ephemeral: true });
                }
                break;
            case 'perma':
                await database_info.table.create({ "user_id": user_id, "role_id": role.role_id, "end_time": Number.POSITIVE_INFINITY });
                await interaction?.reply({ content: `Role <@&${role.role_id}> will now last forever`, ephemeral: true }); 
                break;
            case 'remove':
                await interaction?.reply({ content: `Nothing to remove`, ephemeral: true });
        }
    } else { // if entry, update
        switch (option?.duration?.value) {
            case undefined:
            case null:
                instances[0].update({ end_time: new Date().getTime() + role.role_duration });
                if ((option?.qualifier == null) || (option?.qualifier == undefined)) {
                    await interaction?.reply({ content: `Timer reset back to ${minitify(role.role_duration)} ${(minitify(role.role_duration) == 1) ? ('minute') : ('minutes')} for role <@&${role.role_id}>`, ephemeral: true });
                } else {
                    const qualifier_duration = (option.qualifier.value == null) ? (minitify(role.role_duration)) : (minitify(option.qualifier.value));
                    await interaction?.reply({ content: `Timer reset back to ${qualifier_duration} ${(qualifier_duration == 1) ? ('minute') : ('minutes')} for role <@&${role.role_id}>`, ephemeral: true });
                }
                break;
            case 'perma':
                instances[0].update({ end_time: Number.POSITIVE_INFINITY });
                await interaction?.reply({ content: `Role <@&${role.role_id}> will now last forever`, ephemeral: true }); 
                break; 
            case 'remove':
                await removeRoleFromUser(role, interaction);
                await deleteFromDatabase(database_info, { user_id: user_id, role_id: role.role_id });
                await interaction?.reply({ content: `Removed role <@&${role.role_id}>`, ephemeral: true }); 
        }
    }
}

// ------------------------------------------------------
// @description Check all users in each role group to see if they're in the database or not.
// If the user isn't in the database, add them to it with the role given for infinite time (permanent)
//   - NOTE: This function is used as a means to retrack all users in the server that may have a role added by some means other than this bot
// @params database_info: a reference to the database
// @params client: the discord client object
// @return the number of users added to the database
// ------------------------------------------------------
async function rescanUserbase(database_info, client) {
    let num_users_added_to_database = 0;
    const guild = client.guilds.cache.get(guildId);
    for (const role of roles) {
        const ids = guild.roles.cache.get(role.role_id).members.map(m => m.user.id);
        for (const id of ids) {
            const is_in_database = await isInDatabase(database_info, { user_id: id, role_id: role.role_id });
            if (!is_in_database) {
                num_users_added_to_database++;
                await createOrUpdateDatabase(database_info, role, null, 'perma', id);
            }
        }
    }
    return num_users_added_to_database;
}

// ------------------------------------------------------
// @description Check every entry in the database to see if each recorded user is still in the server or not
// If the user isn't found anymore (i.e., they left the server) delete the entry from the database
// @params database_info: a reference to the database
// @params client: the discord client object
// @return the number of entries deleted from the database
// ------------------------------------------------------
async function cleanDatabase(database_info, client) {
    let num_entries_deleted = 0;
    const contents = await database_info.table.findAll();
    const guild = client.guilds.cache.get(guildId);
    for (const content of contents) {
        const member = guild.members.cache.get(content.user_id);
        if (member == undefined) {
            await database_info.table.destroy({
                where: {
                    user_id: content.user_id,
                },
            });
            num_entries_deleted++;
        } 
    }
    return num_entries_deleted;
}

// ------------------------------------------------------
// @description Print the entire database in a discord message (message is ephemeral, i.e., it can only be viewed by the user who executed the command)
//   - NOTE: this is a DANGEROUS function and should only be executed by moderators/admins
// @params database_info: a reference to the database
// @params interaction: the discord interaction object generated by the user interaction.member (the one who executed the command)
// @params print_in_terminal_instead: <-[UNUSED] prints the database in the terminal instead of sending it as a discord message
// ------------------------------------------------------
async function printDatabaseToConsole(database_info, interaction, print_in_terminal_instead=false) {
    let database_string = '';
    try {
        await checkDatabase(database_info, null);
        const contents = await database_info.table.findAll();

        for (const content of contents) {
            database_string += `---------------------\n\tuser_id: ${content.user_id}\n\trole_id: ${content.role_id}\n\tend_time: ${content.end_time}\n`;
        }
        if (database_string != '') database_string += `---------------------`;
        else database_string = 'EMPTY DATABASE';
        if (print_in_terminal_instead) console.log(database_string);
        else await interaction?.reply({ content: `${database_string}`, ephemeral: true }); 
    } catch (e) {
        if (print_in_terminal_instead) console.log(`[ERROR] [DATABASE] ${e}`);
        else await interaction?.reply({ content: `[ERROR] [DATABASE] ${e}`, ephemeral: true }); 
    }
}

// -----------------------EXPORTS-----------------------
module.exports = { 
                    getDatabase, 
                    removeRoleFromUser,
                    addRoleToUser,
                    clearDatabase,
                    checkDatabase,
                    deleteFromDatabase, 
                    createOrUpdateDatabase, 
                    rescanUserbase,
                    cleanDatabase,
                    printDatabaseToConsole, 
                    isInDatabase
                };